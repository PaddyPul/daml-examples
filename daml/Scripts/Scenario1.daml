module Scripts.Scenario1 where
import Daml.Script
import Main
import Scripts.LedgerPartySetup
import qualified DA.TextMap as DATextMap
import DA.List (tail, head)

creatingDoodle : LedgerParties -> Script(ContractId Doodle)
creatingDoodle parties = script do
    doodle <-  submit parties.organizer do 
        createCmd Doodle with 
            name = "SampleDoodle"
            organizer = parties.organizer
            voters = []
            options = []
            votes = DATextMap.empty
            open = True
    return (doodle)

addVoter : Text ->LedgerParties -> Script (ContractId Doodle)
addVoter doodleName parties = script do
    [(doodle,_)]<- queryFilter @Doodle parties.organizer
      (\d -> (d.name == "SampleDoodle"))
    
    
    () <-  submitMustFail parties.organizer do 
        exerciseCmd doodle AddVoter with 
            voter = parties.voter4

    -- voter already added to doodle
    () <-  submitMustFail parties.organizer do 
        exerciseCmd doodle AddVoter with 
            voter = parties.voter1
    return (doodle)

addVoters : LedgerParties ->Text->[Party]-> Script [ContractId Doodle]
addVoters parties doodleName [] = pure [] -- no voters so nothing is done
addVoters parties doodleName newVoters = script do 
    [(doodle,_)]<- queryFilter @Doodle parties.organizer
      (\d -> (d.name == doodleName))
-- at least one voter, create that
    doodlecId <- submit parties.organizer $ exerciseCmd doodle AddVoter with voter = head newVoters
-- then recursively call AddVoter to handle the tail of the list
    doodlecIds <- addVoters parties doodleName (tail newVoters)
    return (doodlecId::doodlecIds)